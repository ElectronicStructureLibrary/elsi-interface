<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SuperLUDistributed: EXAMPLE/pdgssvx.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>EXAMPLE/pdgssvx.c File Reference</h1>Solves a system of linear equations A*X=B. <a href="#_details">More...</a>
<p>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &quot;<a class="el" href="superlu__ddefs_8h-source.html">superlu_ddefs.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="EXAMPLE_2pdgssvx_8c.html#adf1d6e62c7751bcfc178a70dcef56ad">pdgssvx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *options, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *A, <a class="el" href="structScalePermstruct__t.html">ScalePermstruct_t</a> *ScalePermstruct, double B[], int ldb, int nrhs, <a class="el" href="structgridinfo__t.html">gridinfo_t</a> *grid, <a class="el" href="structLUstruct__t.html">LUstruct_t</a> *LUstruct, <a class="el" href="structSOLVEstruct__t.html">SOLVEstruct_t</a> *SOLVEstruct, double *berr, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *stat, int *info)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<pre>
 -- Distributed SuperLU routine (version 2.0) --
 Lawrence Berkeley National Lab, Univ. of California Berkeley.
 March 15, 2003
 </pre> <hr><h2>Function Documentation</h2>
<a class="anchor" name="adf1d6e62c7751bcfc178a70dcef56ad"></a><!-- doxytag: member="pdgssvx.c::pdgssvx" ref="adf1d6e62c7751bcfc178a70dcef56ad" args="(superlu_options_t *options, SuperMatrix *A, ScalePermstruct_t *ScalePermstruct, double B[], int ldb, int nrhs, gridinfo_t *grid, LUstruct_t *LUstruct, SOLVEstruct_t *SOLVEstruct, double *berr, SuperLUStat_t *stat, int *info)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void pdgssvx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structScalePermstruct__t.html">ScalePermstruct_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ScalePermstruct</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>B</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structgridinfo__t.html">gridinfo_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structLUstruct__t.html">LUstruct_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>LUstruct</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSOLVEstruct__t.html">SOLVEstruct_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>SOLVEstruct</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>berr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> PDGSSVX solves a system of linear equations A*X=B,
 by using Gaussian elimination with "static pivoting" to
 compute the LU factorization of A.</pre><p>
<pre> Static pivoting is a technique that combines the numerical stability
 of partial pivoting with the scalability of Cholesky (no pivoting),
 to run accurately and efficiently on large numbers of processors.
 See our paper at <a href="http://www.nersc.gov/~xiaoye/SuperLU/">http://www.nersc.gov/~xiaoye/SuperLU/</a> for a detailed
 description of the parallel algorithms.</pre><p>
<pre> The input matrices A and B are distributed by block rows.
 Here is a graphical illustration (0-based indexing):</pre><p>
<pre>                        A                B
               0 ---------------       ------
                   |           |        |  |
                   |           |   P0   |  |
                   |           |        |  |
                 ---------------       ------<ul>
<li>fst_row-&gt;|           |        |  |
        |          |           |        |  |
       m_loc       |           |   P1   |  |
        |          |           |        |  |</li><li>|           |        |  |
                 ---------------       ------
                   |    .      |        |. |
                   |    .      |        |. |
                   |    .      |        |. |
                 ---------------       ------</li></ul>
</pre><p>
<pre> where, fst_row is the row number of the first row,
        m_loc is the number of rows local to this processor
 These are defined in the 'SuperMatrix' structure, see <a class="el" href="supermatrix_8h.html">supermatrix.h</a>.</pre><p>
<pre> Here are the options for using this code:</pre><p>
<pre>   1. Independent of all the other options specified below, the
      user must supply</pre><p>
<pre><ul>
<li>B, the matrix of right-hand sides, distributed by block rows,
            and its dimensions ldb (local) and nrhs (global)</li><li>grid, a structure describing the 2D processor mesh</li><li>options-&gt;IterRefine, which determines whether or not to
            improve the accuracy of the computed solution using 
            iterative refinement</li></ul>
</pre><p>
<pre>      On output, B is overwritten with the solution X.</pre><p>
<pre>   2. Depending on options-&gt;Fact, the user has four options
      for solving A*X=B. The standard option is for factoring
      A "from scratch". (The other options, described below,
      are used when A is sufficiently similar to a previously 
      solved problem to save time by reusing part or all of 
      the previous factorization.)</pre><p>
<pre><ul>
<li>options-&gt;Fact = DOFACT: A is factored "from scratch"</li></ul>
</pre><p>
<pre>      In this case the user must also supply</pre><p>
<pre>        o  A, the input matrix</pre><p>
<pre>        as well as the following options to determine what matrix to
        factorize.</pre><p>
<pre>        o  options-&gt;Equil,   to specify how to scale the rows and columns
                             of A to "equilibrate" it (to try to reduce its
                             condition number and so improve the
                             accuracy of the computed solution)</pre><p>
<pre>        o  options-&gt;RowPerm, to specify how to permute the rows of A
                             (typically to control numerical stability)</pre><p>
<pre>        o  options-&gt;ColPerm, to specify how to permute the columns of A
                             (typically to control fill-in and enhance
                             parallelism during factorization)</pre><p>
<pre>        o  options-&gt;ReplaceTinyPivot, to specify how to deal with tiny
                             pivots encountered during factorization
                             (to control numerical stability)</pre><p>
<pre>      The outputs returned include</pre><p>
<pre>        o  ScalePermstruct,  modified to describe how the input matrix A
                             was equilibrated and permuted:
          .  ScalePermstruct-&gt;DiagScale, indicates whether the rows and/or
                                         columns of A were scaled
          .  ScalePermstruct-&gt;R, array of row scale factors
          .  ScalePermstruct-&gt;C, array of column scale factors
          .  ScalePermstruct-&gt;perm_r, row permutation vector
          .  ScalePermstruct-&gt;perm_c, column permutation vector</pre><p>
<pre>          (part of ScalePermstruct may also need to be supplied on input,
           depending on options-&gt;RowPerm and options-&gt;ColPerm as described 
           later).</pre><p>
<pre>        o  A, the input matrix A overwritten by the scaled and permuted
              matrix diag(R)*A*diag(C)*Pc^T, where 
              Pc is the row permutation matrix determined by
                  ScalePermstruct-&gt;perm_c
              diag(R) and diag(C) are diagonal scaling matrices determined
                  by ScalePermstruct-&gt;DiagScale, ScalePermstruct-&gt;R and 
                  ScalePermstruct-&gt;C</pre><p>
<pre>        o  LUstruct, which contains the L and U factorization of A1 where</pre><p>
<pre>                A1 = Pc*Pr*diag(R)*A*diag(C)*Pc^T = L*U</pre><p>
<pre>               (Note that A1 = Pc*Pr*Aout, where Aout is the matrix stored
                in A on output.)</pre><p>
<pre>   3. The second value of options-&gt;Fact assumes that a matrix with the same
      sparsity pattern as A has already been factored:</pre><p>
<pre><ul>
<li>options-&gt;Fact = SamePattern: A is factored, assuming that it has
            the same nonzero pattern as a previously factored matrix. In
            this case the algorithm saves time by reusing the previously
            computed column permutation vector stored in
            ScalePermstruct-&gt;perm_c and the "elimination tree" of A
            stored in LUstruct-&gt;etree</li></ul>
</pre><p>
<pre>      In this case the user must still specify the following options
      as before:</pre><p>
<pre>        o  options-&gt;Equil
        o  options-&gt;RowPerm
        o  options-&gt;ReplaceTinyPivot</pre><p>
<pre>      but not options-&gt;ColPerm, whose value is ignored. This is because the
      previous column permutation from ScalePermstruct-&gt;perm_c is used as
      input. The user must also supply</pre><p>
<pre>        o  A, the input matrix
        o  ScalePermstruct-&gt;perm_c, the column permutation
        o  LUstruct-&gt;etree, the elimination tree</pre><p>
<pre>      The outputs returned include</pre><p>
<pre>        o  A, the input matrix A overwritten by the scaled and permuted
              matrix as described above
        o  ScalePermstruct, modified to describe how the input matrix A was
                            equilibrated and row permuted
        o  LUstruct, modified to contain the new L and U factors</pre><p>
<pre>   4. The third value of options-&gt;Fact assumes that a matrix B with the same
      sparsity pattern as A has already been factored, and where the
      row permutation of B can be reused for A. This is useful when A and B
      have similar numerical values, so that the same row permutation
      will make both factorizations numerically stable. This lets us reuse
      all of the previously computed structure of L and U.</pre><p>
<pre><ul>
<li>options-&gt;Fact = SamePattern_SameRowPerm: A is factored,
            assuming not only the same nonzero pattern as the previously
            factored matrix B, but reusing B's row permutation.</li></ul>
</pre><p>
<pre>      In this case the user must still specify the following options
      as before:</pre><p>
<pre>        o  options-&gt;Equil
        o  options-&gt;ReplaceTinyPivot</pre><p>
<pre>      but not options-&gt;RowPerm or options-&gt;ColPerm, whose values are
      ignored. This is because the permutations from ScalePermstruct-&gt;perm_r
      and ScalePermstruct-&gt;perm_c are used as input.</pre><p>
<pre>      The user must also supply</pre><p>
<pre>        o  A, the input matrix
        o  ScalePermstruct-&gt;DiagScale, how the previous matrix was row
                                       and/or column scaled
        o  ScalePermstruct-&gt;R, the row scalings of the previous matrix,
                               if any
        o  ScalePermstruct-&gt;C, the columns scalings of the previous matrix, 
                               if any
        o  ScalePermstruct-&gt;perm_r, the row permutation of the previous
                                    matrix
        o  ScalePermstruct-&gt;perm_c, the column permutation of the previous 
                                    matrix
        o  all of LUstruct, the previously computed information about
                            L and U (the actual numerical values of L and U
                            stored in LUstruct-&gt;Llu are ignored)</pre><p>
<pre>      The outputs returned include</pre><p>
<pre>        o  A, the input matrix A overwritten by the scaled and permuted
              matrix as described above
        o  ScalePermstruct,  modified to describe how the input matrix A was
                             equilibrated (thus ScalePermstruct-&gt;DiagScale,
                             R and C may be modified)
        o  LUstruct, modified to contain the new L and U factors</pre><p>
<pre>   5. The fourth and last value of options-&gt;Fact assumes that A is
      identical to a matrix that has already been factored on a previous 
      call, and reuses its entire LU factorization</pre><p>
<pre><ul>
<li>options-&gt;Fact = Factored: A is identical to a previously
            factorized matrix, so the entire previous factorization
            can be reused.</li></ul>
</pre><p>
<pre>      In this case all the other options mentioned above are ignored
      (options-&gt;Equil, options-&gt;RowPerm, options-&gt;ColPerm, 
       options-&gt;ReplaceTinyPivot)</pre><p>
<pre>      The user must also supply</pre><p>
<pre>        o  A, the unfactored matrix, only in the case that iterative
              refinment is to be done (specifically A must be the output
              A from the previous call, so that it has been scaled and permuted)
        o  all of ScalePermstruct
        o  all of LUstruct, including the actual numerical values of
           L and U</pre><p>
<pre>      all of which are unmodified on output.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t* (global)
         The structure defines the input parameters to control
         how the LU decomposition will be performed.
         The following fields should be defined for this structure:</pre><p>
<pre>         o Fact (fact_t)
           Specifies whether or not the factored form of the matrix
           A is supplied on entry, and if not, how the matrix A should
           be factorized based on the previous history.</pre><p>
<pre>           = DOFACT: The matrix A will be factorized from scratch.
                 Inputs:  A
                          options-&gt;Equil, RowPerm, ColPerm, ReplaceTinyPivot
                 Outputs: modified A
                             (possibly row and/or column scaled and/or 
                              permuted)
                          all of ScalePermstruct
                          all of LUstruct</pre><p>
<pre>           = SamePattern: the matrix A will be factorized assuming
             that a factorization of a matrix with the same sparsity
             pattern was performed prior to this one. Therefore, this
             factorization will reuse column permutation vector 
             ScalePermstruct-&gt;perm_c and the elimination tree
             LUstruct-&gt;etree
                 Inputs:  A
                          options-&gt;Equil, RowPerm, ReplaceTinyPivot
                          ScalePermstruct-&gt;perm_c
                          LUstruct-&gt;etree
                 Outputs: modified A
                             (possibly row and/or column scaled and/or 
                              permuted)
                          rest of ScalePermstruct (DiagScale, R, C, perm_r)
                          rest of LUstruct (GLU_persist, Llu)</pre><p>
<pre>           = SamePattern_SameRowPerm: the matrix A will be factorized
             assuming that a factorization of a matrix with the same
             sparsity	pattern and similar numerical values was performed
             prior to this one. Therefore, this factorization will reuse
             both row and column scaling factors R and C, and the
             both row and column permutation vectors perm_r and perm_c,
             distributed data structure set up from the previous symbolic
             factorization.
                 Inputs:  A
                          options-&gt;Equil, ReplaceTinyPivot
                          all of ScalePermstruct
                          all of LUstruct
                 Outputs: modified A
                             (possibly row and/or column scaled and/or 
                              permuted)
                          modified LUstruct-&gt;Llu
           = FACTORED: the matrix A is already factored.
                 Inputs:  all of ScalePermstruct
                          all of LUstruct</pre><p>
<pre>         o Equil (yes_no_t)
           Specifies whether to equilibrate the system.
           = NO:  no equilibration.
           = YES: scaling factors are computed to equilibrate the system:
                      diag(R)*A*diag(C)*inv(diag(C))*X = diag(R)*B.
                  Whether or not the system will be equilibrated depends
                  on the scaling of the matrix A, but if equilibration is
                  used, A is overwritten by diag(R)*A*diag(C) and B by
                  diag(R)*B.</pre><p>
<pre>         o RowPerm (rowperm_t)
           Specifies how to permute rows of the matrix A.
           = NATURAL:   use the natural ordering.
           = LargeDiag: use the Duff/Koster algorithm to permute rows of
                        the original matrix to make the diagonal large
                        relative to the off-diagonal.
           = MY_PERMR:  use the ordering given in ScalePermstruct-&gt;perm_r
                        input by the user.</pre><p>
<pre>         o ColPerm (colperm_t)
           Specifies what type of column permutation to use to reduce fill.
           = NATURAL:       natural ordering.
           = MMD_AT_PLUS_A: minimum degree ordering on structure of A'+A.
           = MMD_ATA:       minimum degree ordering on structure of A'*A.
           = COLAMD:        approximate minimum degree column ordering.
           = MY_PERMC:      the ordering given in ScalePermstruct-&gt;perm_c.</pre><p>
<pre>         o ReplaceTinyPivot (yes_no_t)
           = NO:  do not modify pivots
           = YES: replace tiny pivots by sqrt(epsilon)*norm(A) during 
                  LU factorization.</pre><p>
<pre>         o IterRefine (IterRefine_t)
           Specifies how to perform iterative refinement.
           = NO:     no iterative refinement.
           = DOUBLE: accumulate residual in double precision.
           = EXTRA:  accumulate residual in extra precision.</pre><p>
<pre>         NOTE: all options must be indentical on all processes when
               calling this routine.</pre><p>
<pre> A (input/output) SuperMatrix* (local)
         On entry, matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol).
           The number of linear equations is A-&gt;nrow. The type of A must be:
           Stype = SLU_NR_loc; Dtype = SLU_D; Mtype = SLU_GE.
           That is, A is stored in distributed compressed row format.
           See <a class="el" href="supermatrix_8h.html">supermatrix.h</a> for the definition of 'SuperMatrix'.
           This routine only handles square A, however, the LU factorization
           routine PDGSTRF can factorize rectangular matrices.
         On exit, A may be overwtirren by diag(R)*A*diag(C)*Pc^T,
           depending on ScalePermstruct-&gt;DiagScale and options-&gt;ColPerm:
             if ScalePermstruct-&gt;DiagScale != NOEQUIL, A is overwritten by
                diag(R)*A*diag(C).
             if options-&gt;ColPerm != NATURAL, A is further overwritten by
                diag(R)*A*diag(C)*Pc^T.
           If all the above condition are true, the LU decomposition is
           performed on the matrix Pc*Pr*diag(R)*A*diag(C)*Pc^T.</pre><p>
<pre> ScalePermstruct (input/output) ScalePermstruct_t* (global)
         The data structure to store the scaling and permutation vectors
         describing the transformations performed to the matrix A.
         It contains the following fields:</pre><p>
<pre>         o DiagScale (DiagScale_t)
           Specifies the form of equilibration that was done.
           = NOEQUIL: no equilibration.
           = ROW:     row equilibration, i.e., A was premultiplied by
                      diag(R).
           = COL:     Column equilibration, i.e., A was postmultiplied
                      by diag(C).
           = BOTH:    both row and column equilibration, i.e., A was 
                      replaced by diag(R)*A*diag(C).
           If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm,
           DiagScale is an input argument; otherwise it is an output
           argument.</pre><p>
<pre>         o perm_r (int*)
           Row permutation vector, which defines the permutation matrix Pr;
           perm_r[i] = j means row i of A is in position j in Pr*A.
           If options-&gt;RowPerm = MY_PERMR, or
           options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
           input argument; otherwise it is an output argument.</pre><p>
<pre>         o perm_c (int*)
           Column permutation vector, which defines the 
           permutation matrix Pc; perm_c[i] = j means column i of A is 
           in position j in A*Pc.
           If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern
           or options-&gt;Fact = SamePattern_SameRowPerm, perm_c is an
           input argument; otherwise, it is an output argument.
           On exit, perm_c may be overwritten by the product of the input
           perm_c and a permutation that postorders the elimination tree
           of Pc*A'*A*Pc'; perm_c is not changed if the elimination tree
           is already in postorder.</pre><p>
<pre>         o R (double*) dimension (A-&gt;nrow)
           The row scale factors for A.
           If DiagScale = ROW or BOTH, A is multiplied on the left by 
                          diag(R).
           If DiagScale = NOEQUIL or COL, R is not defined.
           If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm, R is
           an input argument; otherwise, R is an output argument.</pre><p>
<pre>         o C (double*) dimension (A-&gt;ncol)
           The column scale factors for A.
           If DiagScale = COL or BOTH, A is multiplied on the right by 
                          diag(C).
           If DiagScale = NOEQUIL or ROW, C is not defined.
           If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm, C is
           an input argument; otherwise, C is an output argument.</pre><p>
<pre> B       (input/output) double* (local)
         On entry, the right-hand side matrix of dimension (m_loc, nrhs),
           where, m_loc is the number of rows stored locally on my
           process and is defined in the data structure of matrix A.
         On exit, the solution matrix if info = 0;</pre><p>
<pre> ldb     (input) int (local)
         The leading dimension of matrix B.</pre><p>
<pre> nrhs    (input) int (global)
         The number of right-hand sides.
         If nrhs = 0, only LU decomposition is performed, the forward
         and back substitutions are skipped.</pre><p>
<pre> grid    (input) gridinfo_t* (global)
         The 2D process mesh. It contains the MPI communicator, the number
         of process rows (NPROW), the number of process columns (NPCOL),
         and my process rank. It is an input argument to all the
         parallel routines.
         Grid can be initialized by subroutine SUPERLU_GRIDINIT.
         See <a class="el" href="superlu__ddefs_8h.html">superlu_ddefs.h</a> for the definition of 'gridinfo_t'.</pre><p>
<pre> LUstruct (input/output) LUstruct_t*
         The data structures to store the distributed L and U factors.
         It contains the following fields:</pre><p>
<pre>         o etree (int*) dimension (A-&gt;ncol) (global)
           Elimination tree of Pc*(A'+A)*Pc' or Pc*A'*A*Pc'.
           It is computed in <a class="el" href="sp__colorder_8c.html#1621e25f3d4e62c7afe8f979b5aee4a0">sp_colorder()</a> during the first factorization,
           and is reused in the subsequent factorizations of the matrices
           with the same nonzero pattern.
           On exit of <a class="el" href="sp__colorder_8c.html#1621e25f3d4e62c7afe8f979b5aee4a0">sp_colorder()</a>, the columns of A are permuted so that
           the etree is in a certain postorder. This postorder is reflected
           in ScalePermstruct-&gt;perm_c.
           NOTE:
           Etree is a vector of parent pointers for a forest whose vertices
           are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><p>
<pre>         o Glu_persist (Glu_persist_t*) (global)
           Global data structure (xsup, supno) replicated on all processes,
           describing the supernode partition in the factored matrices
           L and U:
	       xsup[s] is the leading column of the s-th supernode,
             supno[i] is the supernode number to which column i belongs.</pre><p>
<pre>         o Llu (LocalLU_t*) (local)
           The distributed data structures to store L and U factors.
           See <a class="el" href="superlu__ddefs_8h.html">superlu_ddefs.h</a> for the definition of 'LocalLU_t'.</pre><p>
<pre> SOLVEstruct (input/output) SOLVEstruct_t*
         The data structure to hold the communication pattern used
         in the phases of triangular solution and iterative refinement.
         This pattern should be intialized only once for repeated solutions.
         If options-&gt;SolveInitialized = YES, it is an input argument.
         If options-&gt;SolveInitialized = NO and nrhs != 0, it is an output
         argument. See <a class="el" href="superlu__ddefs_8h.html">superlu_ddefs.h</a> for the definition of 'SOLVEstruct_t'.</pre><p>
<pre> berr    (output) double*, dimension (nrhs) (global)
         The componentwise relative backward error of each solution   
         vector X(j) (i.e., the smallest relative change in   
         any element of A or B that makes X(j) an exact solution).</pre><p>
<pre> stat   (output) SuperLUStat_t*
        Record the statistics on runtime and floating-point operation count.
        See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
         = 0: successful exit
         &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                so the solution could not be computed.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol.</pre><p>
<pre> See <a class="el" href="superlu__ddefs_8h.html">superlu_ddefs.h</a> for the definitions of varioous data types.
 </pre>     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Aug 9 23:23:52 2008 for SuperLUDistributed by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
