<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SuperLUDistributed: SRC/pdgssvx_ABglobal.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Types</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SRC/pdgssvx_ABglobal.c File Reference</h1>Solves a system of linear equations A*X=B,. <a href="#_details">More...</a>
<p>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &quot;<a class="el" href="superlu__ddefs_8h-source.html">superlu_ddefs.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions/Subroutines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pdgssvx__ABglobal_8c.html#dbb311d0798bdf75dbeffa2691877431">pdgssvx_ABglobal</a> (<a class="el" href="typesuperlu__options__t.html">superlu_options_t</a> *options, <a class="el" href="typeSuperMatrix.html">SuperMatrix</a> *A, <a class="el" href="typeScalePermstruct__t.html">ScalePermstruct_t</a> *ScalePermstruct, double B[], int ldb, int nrhs, <a class="el" href="typegridinfo__t.html">gridinfo_t</a> *grid, <a class="el" href="typeLUstruct__t.html">LUstruct_t</a> *LUstruct, double *berr, <a class="el" href="typeSuperLUStat__t.html">SuperLUStat_t</a> *stat, int *info)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<pre>
 -- Distributed SuperLU routine (version 1.0) --
 Lawrence Berkeley National Lab, Univ. of California Berkeley.
 September 1, 1999
 </pre> <hr><h2>Function Documentation</h2>
<a class="anchor" name="dbb311d0798bdf75dbeffa2691877431"></a><!-- doxytag: member="pdgssvx_ABglobal.c::pdgssvx_ABglobal" ref="dbb311d0798bdf75dbeffa2691877431" args="(superlu_options_t *options, SuperMatrix *A, ScalePermstruct_t *ScalePermstruct, double B[], int ldb, int nrhs, gridinfo_t *grid, LUstruct_t *LUstruct, double *berr, SuperLUStat_t *stat, int *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdgssvx_ABglobal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typesuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeScalePermstruct__t.html">ScalePermstruct_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ScalePermstruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>B</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typegridinfo__t.html">gridinfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeLUstruct__t.html">LUstruct_t</a> *&nbsp;</td>
          <td class="paramname"> <em>LUstruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> pdgssvx_ABglobal solves a system of linear equations A*X=B,
 by using Gaussian elimination with "static pivoting" to
 compute the LU factorization of A.</pre><p>
<pre> Static pivoting is a technique that combines the numerical stability
 of partial pivoting with the scalability of Cholesky (no pivoting),
 to run accurately and efficiently on large numbers of processors.</pre><p>
<pre> See our paper at <a href="http://www.nersc.gov/~xiaoye/SuperLU/">http://www.nersc.gov/~xiaoye/SuperLU/</a> for a detailed
 description of the parallel algorithms.</pre><p>
<pre> Here are the options for using this code:</pre><p>
<pre>   1. Independent of all the other options specified below, the
      user must supply</pre><p>
<pre><ul>
<li>B, the matrix of right hand sides, and its dimensions ldb and nrhs</li><li>grid, a structure describing the 2D processor mesh</li><li>options-&gt;IterRefine, which determines whether or not to
            improve the accuracy of the computed solution using 
            iterative refinement</li></ul>
</pre><p>
<pre>      On output, B is overwritten with the solution X.</pre><p>
<pre>   2. Depending on options-&gt;Fact, the user has several options
      for solving A*X=B. The standard option is for factoring
      A "from scratch". (The other options, described below,
      are used when A is sufficiently similar to a previously 
      solved problem to save time by reusing part or all of 
      the previous factorization.)</pre><p>
<pre><ul>
<li>options-&gt;Fact = DOFACT: A is factored "from scratch"</li></ul>
</pre><p>
<pre>      In this case the user must also supply</pre><p>
<pre><ul>
<li>A, the input matrix</li></ul>
</pre><p>
<pre>      as well as the following options, which are described in more 
      detail below:</pre><p>
<pre><ul>
<li>options-&gt;Equil,   to specify how to scale the rows and columns
                           of A to "equilibrate" it (to try to reduce its
                           condition number and so improve the
                           accuracy of the computed solution)</li></ul>
</pre><p>
<pre><ul>
<li>options-&gt;RowPerm, to specify how to permute the rows of A
                           (typically to control numerical stability)</li></ul>
</pre><p>
<pre><ul>
<li>options-&gt;ColPerm, to specify how to permute the columns of A
                           (typically to control fill-in and enhance
                           parallelism during factorization)</li></ul>
</pre><p>
<pre><ul>
<li>options-&gt;ReplaceTinyPivot, to specify how to deal with tiny
                           pivots encountered during factorization
                           (to control numerical stability)</li></ul>
</pre><p>
<pre>      The outputs returned include</pre><p>
<pre><ul>
<li>ScalePermstruct,  modified to describe how the input matrix A
                           was equilibrated and permuted:<ul>
<li>ScalePermstruct-&gt;DiagScale, indicates whether the rows and/or
                                        columns of A were scaled</li><li>ScalePermstruct-&gt;R, array of row scale factors</li><li>ScalePermstruct-&gt;C, array of column scale factors</li><li>ScalePermstruct-&gt;perm_r, row permutation vector</li><li>ScalePermstruct-&gt;perm_c, column permutation vector</li></ul>
</li></ul>
</pre><p>
<pre>            (part of ScalePermstruct may also need to be supplied on input,
             depending on options-&gt;RowPerm and options-&gt;ColPerm as described 
             later).</pre><p>
<pre><ul>
<li>A, the input matrix A overwritten by the scaled and permuted matrix
                Pc*Pr*diag(R)*A*diag(C)
             where 
                Pr and Pc are row and columns permutation matrices determined
                  by ScalePermstruct-&gt;perm_r and ScalePermstruct-&gt;perm_c, 
                  respectively, and 
                diag(R) and diag(C) are diagonal scaling matrices determined
                  by ScalePermstruct-&gt;DiagScale, ScalePermstruct-&gt;R and 
                  ScalePermstruct-&gt;C</li></ul>
</pre><p>
<pre><ul>
<li>LUstruct, which contains the L and U factorization of A1 where</li></ul>
</pre><p>
<pre>                A1 = Pc*Pr*diag(R)*A*diag(C)*Pc^T = L*U</pre><p>
<pre>              (Note that A1 = Aout * Pc^T, where Aout is the matrix stored
               in A on output.)</pre><p>
<pre>   3. The second value of options-&gt;Fact assumes that a matrix with the same
      sparsity pattern as A has already been factored:</pre><p>
<pre><ul>
<li>options-&gt;Fact = SamePattern: A is factored, assuming that it has
            the same nonzero pattern as a previously factored matrix. In this
            case the algorithm saves time by reusing the previously computed
            column permutation vector stored in ScalePermstruct-&gt;perm_c
            and the "elimination tree" of A stored in LUstruct-&gt;etree.</li></ul>
</pre><p>
<pre>      In this case the user must still specify the following options
      as before:</pre><p>
<pre><ul>
<li>options-&gt;Equil</li><li>options-&gt;RowPerm</li><li>options-&gt;ReplaceTinyPivot</li></ul>
</pre><p>
<pre>      but not options-&gt;ColPerm, whose value is ignored. This is because the
      previous column permutation from ScalePermstruct-&gt;perm_c is used as
      input. The user must also supply</pre><p>
<pre><ul>
<li>A, the input matrix</li><li>ScalePermstruct-&gt;perm_c, the column permutation</li><li>LUstruct-&gt;etree, the elimination tree</li></ul>
</pre><p>
<pre>      The outputs returned include</pre><p>
<pre><ul>
<li>A, the input matrix A overwritten by the scaled and permuted matrix
            as described above</li><li>ScalePermstruct,  modified to describe how the input matrix A was
                           equilibrated and row permuted</li><li>LUstruct, modified to contain the new L and U factors</li></ul>
</pre><p>
<pre>   4. The third value of options-&gt;Fact assumes that a matrix B with the same
      sparsity pattern as A has already been factored, and where the
      row permutation of B can be reused for A. This is useful when A and B
      have similar numerical values, so that the same row permutation
      will make both factorizations numerically stable. This lets us reuse
      all of the previously computed structure of L and U.</pre><p>
<pre><ul>
<li>options-&gt;Fact = SamePattern_SameRowPerm: A is factored,
            assuming not only the same nonzero pattern as the previously
            factored matrix B, but reusing B's row permutation.</li></ul>
</pre><p>
<pre>      In this case the user must still specify the following options
      as before:</pre><p>
<pre><ul>
<li>options-&gt;Equil</li><li>options-&gt;ReplaceTinyPivot</li></ul>
</pre><p>
<pre>      but not options-&gt;RowPerm or options-&gt;ColPerm, whose values are ignored.
      This is because the permutations from ScalePermstruct-&gt;perm_r and
      ScalePermstruct-&gt;perm_c are used as input.</pre><p>
<pre>      The user must also supply</pre><p>
<pre><ul>
<li>A, the input matrix</li><li>ScalePermstruct-&gt;DiagScale, how the previous matrix was row and/or
                                     column scaled</li><li>ScalePermstruct-&gt;R, the row scalings of the previous matrix, if any</li><li>ScalePermstruct-&gt;C, the columns scalings of the previous matrix, 
                             if any</li><li>ScalePermstruct-&gt;perm_r, the row permutation of the previous matrix</li><li>ScalePermstruct-&gt;perm_c, the column permutation of the previous 
                                  matrix</li><li>all of LUstruct, the previously computed information about L and U
                (the actual numerical values of L and U stored in
                 LUstruct-&gt;Llu are ignored)</li></ul>
</pre><p>
<pre>      The outputs returned include</pre><p>
<pre><ul>
<li>A, the input matrix A overwritten by the scaled and permuted matrix
            as described above</li><li>ScalePermstruct,  modified to describe how the input matrix A was
                           equilibrated 
                  (thus ScalePermstruct-&gt;DiagScale, R and C may be modified)</li><li>LUstruct, modified to contain the new L and U factors</li></ul>
</pre><p>
<pre>   5. The fourth and last value of options-&gt;Fact assumes that A is
      identical to a matrix that has already been factored on a previous 
      call, and reuses its entire LU factorization</pre><p>
<pre><ul>
<li>options-&gt;Fact = Factored: A is identical to a previously
            factorized matrix, so the entire previous factorization
            can be reused.</li></ul>
</pre><p>
<pre>      In this case all the other options mentioned above are ignored
      (options-&gt;Equil, options-&gt;RowPerm, options-&gt;ColPerm, 
       options-&gt;ReplaceTinyPivot)</pre><p>
<pre>      The user must also supply</pre><p>
<pre><ul>
<li>A, the unfactored matrix, only in the case that iterative refinment
            is to be done (specifically A must be the output A from 
            the previous call, so that it has been scaled and permuted)</li><li>all of ScalePermstruct</li><li>all of LUstruct, including the actual numerical values of L and U</li></ul>
</pre><p>
<pre>      all of which are unmodified on output.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed.
         The following fields should be defined for this structure:</pre><p>
<pre>         o Fact (fact_t)
           Specifies whether or not the factored form of the matrix
           A is supplied on entry, and if not, how the matrix A should
           be factorized based on the previous history.</pre><p>
<pre>           = DOFACT: The matrix A will be factorized from scratch.
                 Inputs:  A
                          options-&gt;Equil, RowPerm, ColPerm, ReplaceTinyPivot
                 Outputs: modified A
                             (possibly row and/or column scaled and/or 
                              permuted)
                          all of ScalePermstruct
                          all of LUstruct</pre><p>
<pre>           = SamePattern: the matrix A will be factorized assuming
             that a factorization of a matrix with the same sparsity
             pattern was performed prior to this one. Therefore, this
             factorization will reuse column permutation vector 
             ScalePermstruct-&gt;perm_c and the elimination tree
             LUstruct-&gt;etree
                 Inputs:  A
                          options-&gt;Equil, RowPerm, ReplaceTinyPivot
                          ScalePermstruct-&gt;perm_c
                          LUstruct-&gt;etree
                 Outputs: modified A
                             (possibly row and/or column scaled and/or 
                              permuted)
                          rest of ScalePermstruct (DiagScale, R, C, perm_r)
                          rest of LUstruct (GLU_persist, Llu)</pre><p>
<pre>           = SamePattern_SameRowPerm: the matrix A will be factorized
             assuming that a factorization of a matrix with the same
             sparsity	pattern and similar numerical values was performed
             prior to this one. Therefore, this factorization will reuse
             both row and column scaling factors R and C, and the
             both row and column permutation vectors perm_r and perm_c,
             distributed data structure set up from the previous symbolic
             factorization.
                 Inputs:  A
                          options-&gt;Equil, ReplaceTinyPivot
                          all of ScalePermstruct
                          all of LUstruct
                 Outputs: modified A
                             (possibly row and/or column scaled and/or 
                              permuted)
                          modified LUstruct-&gt;Llu
           = FACTORED: the matrix A is already factored.
                 Inputs:  all of ScalePermstruct
                          all of LUstruct</pre><p>
<pre>         o Equil (yes_no_t)
           Specifies whether to equilibrate the system.
           = NO:  no equilibration.
           = YES: scaling factors are computed to equilibrate the system:
                      diag(R)*A*diag(C)*inv(diag(C))*X = diag(R)*B.
                  Whether or not the system will be equilibrated depends
                  on the scaling of the matrix A, but if equilibration is
                  used, A is overwritten by diag(R)*A*diag(C) and B by
                  diag(R)*B.</pre><p>
<pre>         o RowPerm (rowperm_t)
           Specifies how to permute rows of the matrix A.
           = NATURAL:   use the natural ordering.
           = LargeDiag: use the Duff/Koster algorithm to permute rows of
                        the original matrix to make the diagonal large
                        relative to the off-diagonal.
           = MY_PERMR:  use the ordering given in ScalePermstruct-&gt;perm_r
                        input by the user.</pre><p>
<pre>         o ColPerm (colperm_t)
           Specifies what type of column permutation to use to reduce fill.
           = NATURAL:       natural ordering.
           = MMD_AT_PLUS_A: minimum degree ordering on structure of A'+A.
           = MMD_ATA:       minimum degree ordering on structure of A'*A.
           = MY_PERMC:      the ordering given in ScalePermstruct-&gt;perm_c.</pre><p>
<pre>         o ReplaceTinyPivot (yes_no_t)
           = NO:  do not modify pivots
           = YES: replace tiny pivots by sqrt(epsilon)*norm(A) during 
                  LU factorization.</pre><p>
<pre>         o IterRefine (IterRefine_t)
           Specifies how to perform iterative refinement.
           = NO:     no iterative refinement.
           = DOUBLE: accumulate residual in double precision.
           = EXTRA:  accumulate residual in extra precision.</pre><p>
<pre>         NOTE: all options must be indentical on all processes when
               calling this routine.</pre><p>
<pre> A (input/output) SuperMatrix*
         On entry, matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol).
         The number of linear equations is A-&gt;nrow. The type of A must be:
         Stype = SLU_NC; Dtype = SLU_D; Mtype = SLU_GE. That is, A is stored in
         compressed column format (also known as Harwell-Boeing format).
         See <a class="el" href="supermatrix_8h.html" title="Matrix type definitions.">supermatrix.h</a> for the definition of 'SuperMatrix'.
         This routine only handles square A, however, the LU factorization
         routine pdgstrf can factorize rectangular matrices.
         On exit, A may be overwritten by Pc*Pr*diag(R)*A*diag(C),
         depending on ScalePermstruct-&gt;DiagScale, options-&gt;RowPerm and
         options-&gt;colpem:
             if ScalePermstruct-&gt;DiagScale != NOEQUIL, A is overwritten by
                diag(R)*A*diag(C).
             if options-&gt;RowPerm != NATURAL, A is further overwritten by
                Pr*diag(R)*A*diag(C).
             if options-&gt;ColPerm != NATURAL, A is further overwritten by
                Pc*Pr*diag(R)*A*diag(C).
         If all the above condition are true, the LU decomposition is
         performed on the matrix Pc*Pr*diag(R)*A*diag(C)*Pc^T.</pre><p>
<pre>         NOTE: Currently, A must reside in all processes when calling
               this routine.</pre><p>
<pre> ScalePermstruct (input/output) ScalePermstruct_t*
         The data structure to store the scaling and permutation vectors
         describing the transformations performed to the matrix A.
         It contains the following fields:</pre><p>
<pre>         o DiagScale (DiagScale_t)
           Specifies the form of equilibration that was done.
           = NOEQUIL: no equilibration.
           = ROW:     row equilibration, i.e., A was premultiplied by
                      diag(R).
           = COL:     Column equilibration, i.e., A was postmultiplied
                      by diag(C).
           = BOTH:    both row and column equilibration, i.e., A was 
                      replaced by diag(R)*A*diag(C).
           If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm,
           DiagScale is an input argument; otherwise it is an output
           argument.</pre><p>
<pre>         o perm_r (int*)
           Row permutation vector, which defines the permutation matrix Pr;
           perm_r[i] = j means row i of A is in position j in Pr*A.
           If options-&gt;RowPerm = MY_PERMR, or
           options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
           input argument; otherwise it is an output argument.</pre><p>
<pre>         o perm_c (int*)
           Column permutation vector, which defines the 
           permutation matrix Pc; perm_c[i] = j means column i of A is 
           in position j in A*Pc.
           If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern
           or options-&gt;Fact = SamePattern_SameRowPerm, perm_c is an
           input argument; otherwise, it is an output argument.
           On exit, perm_c may be overwritten by the product of the input
           perm_c and a permutation that postorders the elimination tree
           of Pc*A'*A*Pc'; perm_c is not changed if the elimination tree
           is already in postorder.</pre><p>
<pre>         o R (double*) dimension (A-&gt;nrow)
           The row scale factors for A.
           If DiagScale = ROW or BOTH, A is multiplied on the left by 
                          diag(R).
           If DiagScale = NOEQUIL or COL, R is not defined.
           If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm, R is
           an input argument; otherwise, R is an output argument.</pre><p>
<pre>         o C (double*) dimension (A-&gt;ncol)
           The column scale factors for A.
           If DiagScale = COL or BOTH, A is multiplied on the right by 
                          diag(C).
           If DiagScale = NOEQUIL or ROW, C is not defined.
           If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm, C is
           an input argument; otherwise, C is an output argument.</pre><p>
<pre> B       (input/output) double*
         On entry, the right-hand side matrix of dimension (A-&gt;nrow, nrhs).
         On exit, the solution matrix if info = 0;</pre><p>
<pre>         NOTE: Currently, B must reside in all processes when calling
               this routine.</pre><p>
<pre> ldb     (input) int (global)
         The leading dimension of matrix B.</pre><p>
<pre> nrhs    (input) int (global)
         The number of right-hand sides.
         If nrhs = 0, only LU decomposition is performed, the forward
         and back substitutions are skipped.</pre><p>
<pre> grid    (input) gridinfo_t*
         The 2D process mesh. It contains the MPI communicator, the number
         of process rows (NPROW), the number of process columns (NPCOL),
         and my process rank. It is an input argument to all the
         parallel routines.
         Grid can be initialized by subroutine SUPERLU_GRIDINIT.
         See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definition of 'gridinfo_t'.</pre><p>
<pre> LUstruct (input/output) LUstruct_t*
         The data structures to store the distributed L and U factors.
         It contains the following fields:</pre><p>
<pre>         o etree (int*) dimension (A-&gt;ncol)
           Elimination tree of Pc*(A'+A)*Pc' or Pc*A'*A*Pc', dimension A-&gt;ncol.
           It is computed in <a class="el" href="sp__colorder_8c.html#1621e25f3d4e62c7afe8f979b5aee4a0">sp_colorder()</a> during the first factorization,
           and is reused in the subsequent factorizations of the matrices
           with the same nonzero pattern.
           On exit of <a class="el" href="sp__colorder_8c.html#1621e25f3d4e62c7afe8f979b5aee4a0">sp_colorder()</a>, the columns of A are permuted so that
           the etree is in a certain postorder. This postorder is reflected
           in ScalePermstruct-&gt;perm_c.
           NOTE:
           Etree is a vector of parent pointers for a forest whose vertices
           are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><p>
<pre>         o Glu_persist (Glu_persist_t*)
           Global data structure (xsup, supno) replicated on all processes,
           describing the supernode partition in the factored matrices
           L and U:
	       xsup[s] is the leading column of the s-th supernode,
             supno[i] is the supernode number to which column i belongs.</pre><p>
<pre>         o Llu (LocalLU_t*)
           The distributed data structures to store L and U factors.
           See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definition of 'LocalLU_t'.</pre><p>
<pre> berr    (output) double*, dimension (nrhs)
         The componentwise relative backward error of each solution   
         vector X(j) (i.e., the smallest relative change in   
         any element of A or B that makes X(j) an exact solution).</pre><p>
<pre> stat   (output) SuperLUStat_t*
        Record the statistics on runtime and floating-point operation count.
        See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
         = 0: successful exit
         &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                so the solution could not be computed.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol.</pre><p>
<pre> See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definitions of various data types.
 </pre> 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Aug 30 14:36:33 2011 for SuperLUDistributed by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
